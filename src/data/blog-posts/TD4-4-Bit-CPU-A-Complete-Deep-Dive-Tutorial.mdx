---
title: TD4 4-Bit CPU A Complete Deep-Dive Tutorial
slug: td4-4-bit-cpu-a-complete-deep-dive-tutorial
publishDate: 2025-11-27
description: Learn about TD4 4-Bit CPU A Complete Deep-Dive Tutorial.
date: 2025-11-27
tags: ['TD4 4-bit CPU']
draft: false
---
# TD4 4-Bit CPU: A Complete Deep-Dive Tutorial

## Table of Contents
1. [Introduction](#1-introduction)
2. [Historical Context](#2-historical-context)
3. [Architecture Overview](#3-architecture-overview)
4. [Component Breakdown](#4-component-breakdown)
5. [Instruction Set Architecture](#5-instruction-set-architecture)
6. [Data Path Analysis](#6-data-path-analysis)
7. [Control Logic](#7-control-logic)
8. [Clock and Reset Circuitry](#8-clock-and-reset-circuitry)
9. [Step-by-Step Operation](#9-step-by-step-operation)
10. [Building the TD4](#10-building-the-td4)
11. [Example Programs](#11-example-programs)
12. [Extensions and Modifications](#12-extensions-and-modifications)

---

## 1. Introduction

### What is the TD4?

The TD4 (often written as TD4-4BIT-CPU) is a minimalist 4-bit CPU designed for educational purposes. The name "TD4" comes from the Japanese book title "CPU no Tsukurikata" (CPUã®å‰µã‚Šã‹ãŸ - "How to Make a CPU") by **Watanabe Tetsuya**, published in 2003.

### Why Study the TD4?

The TD4 is exceptional for learning because:

- **Minimal complexity**: Only 10 ICs total (all 74HC series)
- **No microcode**: Direct hardware instruction decoding
- **Transparent operation**: Every signal can be traced and understood
- **Buildable**: Can be constructed on a breadboard in a few hours
- **Complete**: Despite its simplicity, it's a fully functional stored-program computer

### Design Philosophy

The TD4 strips a CPU down to its absolute essentials:
- 4-bit data bus
- 4-bit address space (16 bytes of program memory)
- 4 registers (2 general-purpose, 1 output, 1 program counter)
- 16 instructions (4-bit opcode)
- Single accumulator architecture with carry flag

---

## 2. Historical Context

### The Book and Its Impact

Watanabe Tetsuya's book became a cult classic in Japan among electronics hobbyists and students. It walks readers through building a CPU from scratch using only commonly available 74HC logic ICs.

### Educational Lineage

The TD4 fits into a lineage of educational CPUs:

```
Simple Logic Gates
       â†“
   Adders/ALUs
       â†“
    SAP-1 (Simple As Possible)
       â†“
      TD4 â†â”€â”€ You are here
       â†“
    HACK (Nand2Tetris)
       â†“
  Real CPUs (6502, Z80, etc.)
```

The TD4 occupies a sweet spot: complex enough to be a real CPU, simple enough to fully understand.

---

## 3. Architecture Overview

### Block Diagram

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                        TD4 CPU                          â”‚
                    â”‚                                                         â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚  â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”                                     â”‚
   â”‚ Clock  â”‚â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚ PC  â”‚â”€â”€â”€â–¶â”‚ ROM â”‚â”€â”€â”¬â”€ OPCODE[7:4] â”€â”€â–¶ Instruction    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚  â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜  â”‚                   Decoder        â”‚
                    â”‚     â–²                â”‚                      â”‚           â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚     â”‚                â”‚                      â–¼           â”‚
   â”‚ Reset  â”‚â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤                â”‚              Control Signals     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚     â”‚                â”‚                      â”‚           â”‚
                    â”‚     â”‚                â””â”€ IM[3:0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
                    â”‚     â”‚                    (Immediate)           â”‚        â”‚
                    â”‚  â”Œâ”€â”€â”´â”€â”€â”                                       â–¼        â”‚
                    â”‚  â”‚ +1  â”‚â—€â”€â”€ Carry â—€â”€â”€ â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”˜              â”‚ ALU â”‚â—€â”€â”€â”€â”‚ MUX â”‚â—€â”€â”€â”€â”‚ A/B â”‚    â”‚
                    â”‚                       â”‚ ADD â”‚    â”‚ 4:1 â”‚    â”‚ Reg â”‚    â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚                       â””â”€â”€â”¬â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â”‚
   â”‚  IN    â”‚â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²                   â”‚
   â”‚ Port   â”‚       â”‚                          â”‚          â”‚                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚                          â–¼          â”‚                   â”‚
                    â”‚                       â”Œâ”€â”€â”€â”€â”€â”       â”‚                   â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚                       â”‚ OUT â”‚â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
   â”‚  OUT   â”‚â—€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ Reg â”‚                           â”‚
   â”‚ Port   â”‚       â”‚                       â””â”€â”€â”€â”€â”€â”˜                           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚                                                         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Register Set

| Register | Name | Size | Description |
|----------|------|------|-------------|
| A | Accumulator A | 4-bit | General purpose register |
| B | Accumulator B | 4-bit | General purpose register |
| OUT | Output Register | 4-bit | Connected to output port (directly drives LEDs) |
| PC | Program Counter | 4-bit | Points to current instruction (0-15) |
| C | Carry Flag | 1-bit | Set when ALU produces carry-out |

### Memory Map

```
Address    Content
0x0        Instruction 0
0x1        Instruction 1
...        ...
0xF        Instruction 15  (only 16 bytes total!)
```

---

## 4. Component Breakdown

### Complete Parts List

| Qty | Part Number | Function |
|-----|-------------|----------|
| 2 | 74HC161 | 4-bit binary counter (PC and Address) |
| 2 | 74HC153 | Dual 4-to-1 multiplexer |
| 1 | 74HC283 | 4-bit binary adder |
| 2 | 74HC74 | Dual D flip-flop (registers) |
| 1 | 74HC540 | Octal buffer with inverted outputs |
| 1 | 74HC10 | Triple 3-input NAND |
| 1 | ROM | 16Ã—8 (can use DIP switches, EEPROM, or diode matrix) |

### 4.1 74HC161 - Program Counter

The 74HC161 is a synchronous 4-bit binary counter with parallel load capability.

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   CLR â”€â”¤1           16â”œâ”€ VCC
   CLK â”€â”¤2           15â”œâ”€ RCO (Ripple Carry Out)
    D0 â”€â”¤3           14â”œâ”€ Q0
    D1 â”€â”¤4           13â”œâ”€ Q1
    D2 â”€â”¤5           12â”œâ”€ Q2
    D3 â”€â”¤6           11â”œâ”€ Q3
   ENP â”€â”¤7           10â”œâ”€ ENT
   GND â”€â”¤8            9â”œâ”€ LOAD
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**In TD4, this IC serves as the Program Counter:**
- On each clock pulse (with ENP and ENT high), it counts up: 0â†’1â†’2â†’...â†’15â†’0
- When LOAD is asserted low, it loads a new address (for JMP instruction)
- CLR resets to 0 (system reset)

**Key insight**: The PC doesn't just countâ€”it can also be loaded with an immediate value for jumps!

### 4.2 74HC153 - Data Selector (MUX)

The 74HC153 contains two independent 4-to-1 multiplexers.

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   1Ea â”€â”¤1           16â”œâ”€ VCC
    S1 â”€â”¤2           15â”œâ”€ 2Ea
  1I3a â”€â”¤3           14â”œâ”€ S0
  1I2a â”€â”¤4           13â”œâ”€ 2I3a
  1I1a â”€â”¤5           12â”œâ”€ 2I2a
  1I0a â”€â”¤6           11â”œâ”€ 2I1a
   1Ya â”€â”¤7           10â”œâ”€ 2I0a
   GND â”€â”¤8            9â”œâ”€ 2Ya
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**In TD4, two 74HC153s form a 4-bit wide 4:1 MUX:**

```
Select bits S1 S0:
   00 â†’ Select Register A
   01 â†’ Select Register B
   10 â†’ Select Input Port
   11 â†’ Select 0000 (constant zero)
```

This MUX selects what goes to one input of the ALU.

### 4.3 74HC283 - 4-Bit Adder (The ALU)

The 74HC283 is a 4-bit binary full adder with fast carry.

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   Î£2 â”€â”¤1           16â”œâ”€ VCC
   B2 â”€â”¤2           15â”œâ”€ B3
   A2 â”€â”¤3           14â”œâ”€ A3
   Î£1 â”€â”¤4           13â”œâ”€ Î£3
   A1 â”€â”¤5           12â”œâ”€ Î£4
   B1 â”€â”¤6           11â”œâ”€ C4 (Carry Out)
  C0  â”€â”¤7           10â”œâ”€ A4
  GND â”€â”¤8            9â”œâ”€ B4
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**The TD4's ALU is JUST an adder!**

This is a crucial simplification. The TD4 has no subtraction, no AND, no ORâ€”just ADD. Yet it's still Turing complete!

**Operation:**
```
A inputs â† Selected by MUX (A, B, IN, or 0)
B inputs â† Immediate value from instruction [3:0]
Î£ outputs â† A + B + Cin
C4       â† Carry out (stored in carry flip-flop)
```

### 4.4 74HC74 - D Flip-Flops (Registers)

The 74HC74 contains two independent D flip-flops with preset and clear.

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  1CLR â”€â”¤1           14â”œâ”€ VCC
   1D  â”€â”¤2           13â”œâ”€ 2CLR
  1CLK â”€â”¤3           12â”œâ”€ 2D
  1PRE â”€â”¤4           11â”œâ”€ 2CLK
   1Q  â”€â”¤5           10â”œâ”€ 2PRE
  1QÌ„   â”€â”¤6            9â”œâ”€ 2Q
  GND  â”€â”¤7            8â”œâ”€ 2QÌ„
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**In TD4:**
- Two 74HC74s provide 4 flip-flops for registers A and B (2 bits each? Noâ€”see below)
- Actually, the original TD4 uses 74HC161s for A, B, and OUT registers too (they have built-in flip-flops)
- One flip-flop stores the carry flag

### 4.5 74HC540 - Octal Buffer (Output Register)

Used to drive the output LEDs and isolate the output register from the bus.

### 4.6 74HC10 - Triple 3-Input NAND (Instruction Decoder)

The instruction decoder converts the 4-bit opcode into control signals.

---

## 5. Instruction Set Architecture

### Instruction Format

Each instruction is 8 bits:

```
  7   6   5   4   3   2   1   0
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚OP3â”‚OP2â”‚OP1â”‚OP0â”‚IM3â”‚IM2â”‚IM1â”‚IM0â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
â”‚â†â”€â”€ OPCODE â”€â”€â†’â”‚â†â”€â”€ IMMEDIATE â”€â†’â”‚
```

- **OPCODE [7:4]**: Determines the operation
- **IMMEDIATE [3:0]**: 4-bit immediate value (0-15)

### Complete Instruction Set

| Binary | Hex | Mnemonic | Operation | Description |
|--------|-----|----------|-----------|-------------|
| 0000 | 0 | ADD A, Im | A â† A + Im | Add immediate to A |
| 0001 | 1 | MOV A, B | A â† B + 0 | Copy B to A |
| 0010 | 2 | IN A | A â† IN + 0 | Read input port to A |
| 0011 | 3 | MOV A, Im | A â† 0 + Im | Load immediate to A |
| 0100 | 4 | MOV B, A | B â† A + 0 | Copy A to B |
| 0101 | 5 | ADD B, Im | B â† B + Im | Add immediate to B |
| 0110 | 6 | IN B | B â† IN + 0 | Read input port to B |
| 0111 | 7 | MOV B, Im | B â† 0 + Im | Load immediate to B |
| 1000 | 8 | â€” | (unused) | Reserved |
| 1001 | 9 | OUT B | OUT â† B + 0 | Output B to port |
| 1010 | A | â€” | (unused) | Reserved |
| 1011 | B | OUT Im | OUT â† 0 + Im | Output immediate to port |
| 1100 | C | â€” | (unused) | Reserved |
| 1101 | D | â€” | (unused) | Reserved |
| 1110 | E | JNC Im | if C=0: PC â† Im | Jump if no carry |
| 1111 | F | JMP Im | PC â† Im | Unconditional jump |

### Understanding the Instruction Encoding

The brilliance of TD4's instruction encoding lies in how opcodes directly generate control signals:

```
OPCODE bits:
  OP3 OP2 OP1 OP0
   â”‚   â”‚   â”‚   â”‚
   â”‚   â”‚   â””â”€â”€â”€â”´â”€â”€ MUX select (which register feeds ALU)
   â”‚   â”‚              00 = A
   â”‚   â”‚              01 = B  
   â”‚   â”‚              10 = IN
   â”‚   â”‚              11 = 0 (constant)
   â”‚   â”‚
   â””â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Destination select
                     00 = A register
                     01 = B register
                     10 = OUT register
                     11 = PC (jump)
```

**This is incredibly elegant!** The opcode bits ARE the control signals (almost).

---

## 6. Data Path Analysis

### The Central Data Path

```
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚     INSTRUCTION         â”‚
                              â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”     â”‚
                              â”‚   â”‚OPCODE â”‚ IMMED â”‚     â”‚
                              â”‚   â”‚[7:4]  â”‚ [3:0] â”‚     â”‚
                              â”‚   â””â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”¬â”€â”€â”€â”˜     â”‚
                              â”‚       â”‚       â”‚         â”‚
                              â”‚       â–¼       â”‚         â”‚
                              â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”   â”‚         â”‚
                              â”‚   â”‚DECODE â”‚   â”‚         â”‚
                              â”‚   â””â”€â”€â”€â”¬â”€â”€â”€â”˜   â”‚         â”‚
                              â”‚       â”‚       â”‚         â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚       â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                         â”‚       â”‚                  â”‚
            â”‚  SELECT                 â”‚       â”‚  IMMEDIATE       â”‚
            â”‚    â”‚                    â”‚       â”‚    â”‚             â”‚
            â”‚    â–¼                    â”‚       â”‚    â–¼             â”‚
            â”‚  â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”        â”‚       â”‚  â”Œâ”€â”€â”€â”€â”          â”‚
            â”‚  â”‚REG â”‚   â”‚REG â”‚        â”‚       â”‚  â”‚    â”‚          â”‚
            â”‚  â”‚ A  â”‚   â”‚ B  â”‚        â”‚       â”‚  â”‚    â”‚          â”‚
            â”‚  â””â”€â”¬â”€â”€â”˜   â””â”€â”¬â”€â”€â”˜        â”‚       â”‚  â”‚    â”‚          â”‚
            â”‚    â”‚        â”‚           â”‚       â”‚  â”‚    â”‚          â”‚
            â”‚    â–¼        â–¼           â”‚       â”‚  â”‚    â”‚          â”‚
            â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚       â”‚  â”‚    â”‚          â”‚
INPUT â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚  4:1 MUX   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚ADD â”‚â”€â”€â”       â”‚
  PORT      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚       â”‚  â”‚    â”‚  â”‚       â”‚
            â”‚         â–²               â”‚       â”‚  â”‚    â”‚  â”‚       â”‚
            â”‚         â”‚               â”‚       â”‚  â””â”€â”€â”€â”€â”˜  â”‚       â”‚
            â”‚    0000â”€â”˜               â”‚       â”‚    â”‚     â”‚       â”‚
            â”‚                         â”‚       â”‚    â”‚COUT â”‚       â”‚
            â”‚                         â–¼       â”‚    â–¼     â”‚       â”‚
            â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”Œâ”€â”€â”€â”   â”‚       â”‚
            â”‚                    â”‚DEST SELâ”‚   â”‚  â”‚ C â”‚   â”‚       â”‚
            â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚FLGâ”‚   â”‚       â”‚
            â”‚                         â”‚       â”‚  â””â”€â”€â”€â”˜   â”‚       â”‚
            â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚       â”‚
            â”‚    â”‚        â”‚           â”‚                  â”‚       â”‚
            â”‚    â–¼        â–¼           â–¼                  â”‚       â”‚
            â”‚  â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚       â”‚
            â”‚  â”‚REG â”‚   â”‚REG â”‚   â”‚OUT REG â”‚              â”‚       â”‚
            â”‚  â”‚ A  â”‚   â”‚ B  â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜              â”‚       â”‚
            â”‚  â””â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜        â”‚                  â”‚       â”‚
            â”‚                         â–¼                  â”‚       â”‚
            â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚       â”‚
            â”‚                    â”‚ OUTPUT â”‚              â”‚       â”‚
            â”‚                    â”‚  PORT  â”‚              â”‚       â”‚
            â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚       â”‚
            â”‚                                            â”‚       â”‚
            â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
            â”‚            â”‚                                       â”‚
            â”‚            â–¼                                       â”‚
            â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”                      â”‚
            â”‚       â”‚   PC   â”‚â”€â”€â”€â”€â”€â”€â”‚ ROM â”‚                      â”‚
            â”‚       â”‚(74HC161â”‚â—€â”€â”€â”€â”€â”€â”‚     â”‚                      â”‚
            â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”˜                      â”‚
            â”‚            â–²                                       â”‚
            â”‚            â”‚                                       â”‚
            â”‚      CLKâ”€â”€â”€â”˜                                       â”‚
            â”‚                                                    â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Signal Flow for Each Instruction Type

#### ADD A, Im (Opcode 0000)

```
Step 1: PC outputs address â†’ ROM outputs instruction
Step 2: Opcode 0000 decoded:
        - MUX select = 00 (choose A)
        - Dest select = 00 (load A)
Step 3: ALU computes: A + Immediate
Step 4: Rising clock edge:
        - Result loaded into A
        - Carry loaded into C flag
        - PC increments
```

#### JMP Im (Opcode 1111)

```
Step 1: PC outputs address â†’ ROM outputs instruction
Step 2: Opcode 1111 decoded:
        - MUX select = 11 (choose 0)
        - Dest select = 11 (load PC)
        - PC LOAD signal asserted
Step 3: ALU computes: 0 + Immediate = Immediate
Step 4: Rising clock edge:
        - PC loads Immediate value (not increment!)
        - Next instruction fetched from new address
```

---

## 7. Control Logic

### Instruction Decoder Truth Table

| OP3 | OP2 | OP1 | OP0 | LOAD_A | LOAD_B | LOAD_OUT | LOAD_PC | SEL1 | SEL0 |
|-----|-----|-----|-----|--------|--------|----------|---------|------|------|
| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |
| 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 |
| 0 | 1 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0 |
| 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 |
| 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 |
| 1 | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | ~C | 1 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 |

### Decoder Logic Equations

From the truth table, we can derive:

```
LOAD_A  = ~OP3 & ~OP2
LOAD_B  = ~OP3 & OP2
LOAD_OUT = OP3 & ~OP2 & OP0
LOAD_PC = OP3 & OP2 & (OP0 | (OP1 & ~CARRY))
SEL1    = OP1
SEL0    = OP0
```

These equations can be implemented with just a few NAND gates!

### The JNC (Jump if No Carry) Logic

```
JNC instruction (opcode 1110):
  LOAD_PC = OP3 & OP2 & OP1 & ~OP0 & ~CARRY
          = "It's a JNC" AND "Carry is clear"
          
JMP instruction (opcode 1111):
  LOAD_PC = OP3 & OP2 & OP1 & OP0
          = Always load PC (unconditional)
```

Combined:
```
LOAD_PC = OP3 & OP2 & OP1 & (OP0 | ~CARRY)
```

---

## 8. Clock and Reset Circuitry

### Clock Generator Options

#### Option 1: 555 Timer Oscillator
```
                VCC
                 â”‚
                 R1
                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
          â”‚      8      â”‚
     â”Œâ”€â”€â”€â”€â”¤7    555   3 â”œâ”€â”€â”€â”€â”€â”€ CLK OUT
     â”‚    â”‚             â”‚
     R2   â”‚      6 â”€â”€â”€â”€â”€â”¤
     â”‚    â”‚      2 â”€â”€â”€â”€â”€â”¤
     â”œâ”€â”€â”€â”€â”¤             â”‚
     â”‚    â”‚      1      â”‚
     C    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
     â”‚           â”‚
    GND         GND

f â‰ˆ 1.44 / ((R1 + 2Ã—R2) Ã— C)
```

For ~1 Hz clock (easy to observe):
- R1 = 10kÎ©
- R2 = 470kÎ©  
- C = 1ÂµF

#### Option 2: Manual Clock (Push Button)
```
VCC â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLK OUT
         â”‚
        10kÎ©
         â”‚
        â”€â”´â”€
        â”€â”€â”€  Push Button
         â”‚
        GND
```

Add debounce circuit:
```
VCC â”€â”¬â”€ 10kÎ© â”€â”¬â”€ 74HC14 â”€â”¬â”€ 74HC14 â”€â”€â”€ CLK OUT
     â”‚        â”‚          â”‚
   Button     C         (Schmitt trigger for clean edges)
     â”‚       0.1ÂµF
    GND       â”‚
             GND
```

### Reset Circuit

```
         VCC
          â”‚
         10kÎ©
          â”‚
          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ RESET (to all CLR inputs)
          â”‚
       â”€â”€â”€â”´â”€â”€â”€
       â”€â”€â”€â”€â”€â”€â”€  Reset Button
          â”‚
         GND
```

Power-on reset (automatic):
```
VCC â”€â”€â”¬â”€â”€ 10kÎ© â”€â”€â”¬â”€â”€â”€ RESET
      â”‚          â”‚
      â”‚         â”€â”´â”€ 10ÂµF
     â”€â”´â”€         â”‚
     â”€â”€â”€        GND
      â”‚
     GND
```

---

## 9. Step-by-Step Operation

### Execution Cycle

The TD4 executes each instruction in a **single clock cycle**:

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  CLOCK CYCLE                       â”‚
        â”‚                                                    â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”‚
        â”‚  â”‚ FETCH   â”‚  â”‚ DECODE  â”‚  â”‚ EXECUTE â”‚  â”‚ STORE â”‚ â”‚
        â”‚  â”‚         â”‚  â”‚         â”‚  â”‚         â”‚  â”‚       â”‚ â”‚
        â”‚  â”‚ PCâ†’ROM  â”‚  â”‚ Opcode  â”‚  â”‚  ALU    â”‚  â”‚ Regs  â”‚ â”‚
        â”‚  â”‚         â”‚â†’ â”‚ â†’Ctrl   â”‚â†’ â”‚ Compute â”‚â†’ â”‚ Load  â”‚ â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
        â”‚                                                    â”‚
        â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ~1 clock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Clock:  â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€
            â”‚     â”‚                 â”‚     â”‚
            â””â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”˜
                  â–²                       â–²
                  â”‚                       â”‚
            Registers loaded        Next cycle
```

### Detailed Timing

```
Time â†’

CLK:    â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€
             â”‚          â”‚              â”‚          â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PC:     â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•
        ADDRâ”‚     ADDR N     â”‚      ADDR N+1      â”‚
            â”‚                â”‚                    â”‚

ROM:    â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€
            â”‚ OPâ”‚IM (prev)   â”‚    OPâ”‚IM (curr)   â”‚

ALU:    ~~~~â”‚~~~~~~~~~~~~~~~~â”‚~~~~~~~~~~~~~~~~~~~~â”‚~~~~
            â”‚ (computing)    â”‚   (result ready)   â”‚

Regs:   â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•
            â”‚ (previous val) â”‚   (loads new val)  â”‚
            â”‚                â”‚         â–²          â”‚
            â”‚                â”‚         â”‚          â”‚
                                   Register loads
                                   on rising edge
```

### Worked Example: Running a Program

Let's trace through this program:

```
Address  Instruction    Assembly
0x0      0011 0001     MOV A, 1      ; A = 1
0x1      0111 0010     MOV B, 2      ; B = 2
0x2      0001 0000     MOV A, B      ; A = B (A = 2)
0x3      0000 0011     ADD A, 3      ; A = A + 3 = 5
0x4      1011 0000     OUT 0         ; Output = 0 (clear)
0x5      1001 0000     OUT B         ; Output = B = 2
0x6      1111 0000     JMP 0         ; Loop forever
```

**Cycle 0:**
```
PC = 0 â†’ ROM[0] = 0011_0001
Opcode 0011 â†’ MOV A, Im
Immediate = 1
ALU: 0 + 1 = 1
On clock edge: A â† 1, PC â† 1
```

**Cycle 1:**
```
PC = 1 â†’ ROM[1] = 0111_0010
Opcode 0111 â†’ MOV B, Im
Immediate = 2
ALU: 0 + 2 = 2
On clock edge: B â† 2, PC â† 2
```

**Cycle 2:**
```
PC = 2 â†’ ROM[2] = 0001_0000
Opcode 0001 â†’ MOV A, B
MUX selects B (value 2)
ALU: 2 + 0 = 2
On clock edge: A â† 2, PC â† 3
```

**Cycle 3:**
```
PC = 3 â†’ ROM[3] = 0000_0011
Opcode 0000 â†’ ADD A, Im
MUX selects A (value 2)
ALU: 2 + 3 = 5
On clock edge: A â† 5, PC â† 4
```

**Cycle 4:**
```
PC = 4 â†’ ROM[4] = 1011_0000
Opcode 1011 â†’ OUT Im
ALU: 0 + 0 = 0
On clock edge: OUT â† 0, PC â† 5
LEDs show: 0000
```

**Cycle 5:**
```
PC = 5 â†’ ROM[5] = 1001_0000
Opcode 1001 â†’ OUT B
MUX selects B (value 2)
ALU: 2 + 0 = 2
On clock edge: OUT â† 2, PC â† 6
LEDs show: 0010
```

**Cycle 6:**
```
PC = 6 â†’ ROM[6] = 1111_0000
Opcode 1111 â†’ JMP
Immediate = 0
LOAD_PC asserted
On clock edge: PC â† 0 (not PC + 1!)
```

**Cycle 7:**
```
PC = 0 â†’ (Program repeats from beginning)
```

---

## 10. Building the TD4

### Breadboard Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  POWER RAILS                                                â”‚
â”‚  + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ +    â”‚
â”‚  - â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ 74HC161 â”‚  â”‚ 74HC161 â”‚  â”‚ 74HC153 â”‚  â”‚ 74HC153 â”‚        â”‚
â”‚  â”‚   PC    â”‚  â”‚  REG A  â”‚  â”‚  MUX    â”‚  â”‚  MUX    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ 74HC161 â”‚  â”‚ 74HC283 â”‚  â”‚ 74HC10  â”‚  â”‚ 74HC74  â”‚        â”‚
â”‚  â”‚  REG B  â”‚  â”‚  ADDER  â”‚  â”‚ DECODER â”‚  â”‚  CARRY  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ 74HC540 â”‚  â”‚           ROM (DIP SWITCHES)        â”‚      â”‚
â”‚  â”‚   OUT   â”‚  â”‚         16 x 8 bits = 128 switches  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   OR use AT28C16 EEPROM             â”‚      â”‚
â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                             â”‚
â”‚  [CLOCK] [RESET]  [INPUT SWITCHES 0-3]  [OUTPUT LEDS 0-3] â”‚
â”‚                                                             â”‚
â”‚  + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ +    â”‚
â”‚  - â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Wiring Checklist

#### Power Connections (FIRST!)
- [ ] VCC (pin 16) to +5V on all ICs
- [ ] GND (pin 8) to ground on all ICs
- [ ] Add 0.1ÂµF decoupling capacitor near each IC
- [ ] Add 10ÂµF capacitor across main power rails

#### Program Counter (74HC161 #1)
- [ ] CLK (pin 2) â† System clock
- [ ] CLR (pin 1) â† Reset (active low)
- [ ] LOAD (pin 9) â† Instruction decoder (for JMP)
- [ ] D0-D3 (pins 3-6) â† ALU output (for JMP address)
- [ ] Q0-Q3 (pins 14,13,12,11) â†’ ROM address inputs
- [ ] ENP, ENT (pins 7,10) â† Logic for PC enable

#### ROM Connections
- [ ] A0-A3 â† PC outputs
- [ ] D0-D3 â†’ Immediate value to ALU B-input
- [ ] D4-D7 â†’ Opcode to instruction decoder

#### ALU (74HC283)
- [ ] A1-A4 (pins 5,3,14,12) â† MUX output (selected register)
- [ ] B1-B4 (pins 6,2,15,9) â† Immediate from ROM
- [ ] Î£1-Î£4 (pins 4,1,13,10) â†’ Data bus to registers
- [ ] C0 (pin 7) â† GND (or carry-in for future expansion)
- [ ] C4 (pin 9) â†’ Carry flag flip-flop

#### MUX (74HC153 Ã— 2)
Connect in parallel to create 4-bit wide MUX:
- [ ] S0, S1 â† Opcode bits OP0, OP1
- [ ] I0 inputs â† Register A outputs
- [ ] I1 inputs â† Register B outputs
- [ ] I2 inputs â† Input port switches
- [ ] I3 inputs â† GND (constant 0)
- [ ] Y outputs â†’ ALU A-inputs

### ROM Programming Options

#### Option A: DIP Switch Matrix (Most Educational)
```
For each address (0-15):
  - 8 DIP switches set the instruction
  - Address selected by PC through a decoder

       Address 0    Address 1    ...   Address 15
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚   â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚        â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
      â”‚â–“â–“â–“â–“â–‘â–‘â–‘â–‘â”‚   â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚        â”‚â–“â–“â–“â–“â–“â–“â–“â–“â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       0011_0001    0111_0010          1111_0000
       MOV A,1      MOV B,2            JMP 0
```

#### Option B: Diode Matrix ROM (Classic Approach)
```
                Address Lines (from PC)
                A3  A2  A1  A0
                â”‚   â”‚   â”‚   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”
    D7 â”€â”¤   â—„â”€â”€â”€â”¼â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â–º   â”‚
    D6 â”€â”¤   â—„â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â–º   â”‚
    D5 â”€â”¤   â—„â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â—â”€â”€â”€â–º   â”‚
    D4 â”€â”¤   â—„â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â–º   â”‚
    D3 â”€â”¤   â—„â”€â”€â”€â”¼â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â–º   â”‚
    D2 â”€â”¤   â—„â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â–º   â”‚
    D1 â”€â”¤   â—„â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â–º   â”‚
    D0 â”€â”¤   â—„â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â–º   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
    â— = 1N4148 diode (cathode to data line)
    No diode = logic 0
    Diode present = logic 1
```

#### Option C: EEPROM (AT28C16 or similar)
- Most convenient for reprogramming
- Use EEPROM programmer or Arduino to write
- Only need 16 bytes of the 2KB capacity

### Test Points to Add

Add test LEDs or probe points for debugging:
1. Clock signal
2. PC outputs (Q0-Q3)
3. ALU outputs (Î£1-Î£4)
4. Carry flag
5. Each control signal (LOAD_A, LOAD_B, LOAD_OUT, LOAD_PC)

---

## 11. Example Programs

### Program 1: LED Counter (Knight Rider)

```
; Counts 0-15 on output LEDs, then repeats
; Address  Binary      Hex   Assembly
    0      0011_0000   30    MOV A, 0      ; A = 0
    1      1001_0000   90    OUT B         ; (actually OUT A via trick)
    2      0000_0001   01    ADD A, 1      ; A = A + 1
    3      1110_0001   E1    JNC 1         ; If no overflow, goto 1
    4      1111_0000   F0    JMP 0         ; Overflow! Reset
```

Waitâ€”there's no `OUT A` instruction! We need a workaround:

```
; Corrected LED Counter
    0      0011_0000   30    MOV A, 0      ; A = 0
    1      0100_0000   40    MOV B, A      ; B = A
    2      1001_0000   90    OUT B         ; Output B
    3      0000_0001   01    ADD A, 1      ; A++
    4      1110_0001   E1    JNC 1         ; Loop until overflow
    5      1111_0000   F0    JMP 0         ; Start over
```

### Program 2: Alternating Pattern

```
; Alternates between 0101 and 1010 on LEDs
    0      1011_0101   B5    OUT 5         ; Output 0101
    1      1011_1010   BA    OUT 10        ; Output 1010  
    2      1111_0000   F0    JMP 0         ; Repeat
```

### Program 3: Input Echo

```
; Reads input switches and displays on LEDs
    0      0010_0000   20    IN A          ; Read input to A
    1      0100_0000   40    MOV B, A      ; Copy to B
    2      1001_0000   90    OUT B         ; Display B
    3      1111_0000   F0    JMP 0         ; Repeat
```

### Program 4: Addition Calculator

```
; Adds two 4-bit numbers from input
; First input, press button, second input, press button, shows sum
; (Simplified version - assumes clock is manual button)
    0      0010_0000   20    IN A          ; First number
    1      0110_0000   60    IN B          ; Second number
    2      0000_0000   00    ADD A, 0      ; A = A + 0 (sets up for next)
    3      0001_0000   10    MOV A, B      ; A = B
    4      0000_0000   00    ADD A, 0      ; Dummy (need ADD A,B which doesn't exist!)
```

Hmm, TD4 can't directly add A and B. Let's try a different approach:

```
; Add input to running total
    0      0011_0000   30    MOV A, 0      ; Clear accumulator
    1      0110_0000   60    IN B          ; Read input to B
    2      0100_0000   40    MOV B, A      ; Save A to B
    3      0010_0000   20    IN A          ; Read new input to A
    ; ... TD4 is limited here!
```

**Key insight**: TD4's limitations show why real CPUs need more instructions!

### Program 5: Fibonacci Sequence (Partial)

```
; Generates Fibonacci: 1, 1, 2, 3, 5, 8, 13... (mod 16)
; F(n) = F(n-1) + F(n-2)
; Uses A as F(n-1), B as F(n-2)

    0      0011_0001   31    MOV A, 1      ; A = 1 (F1)
    1      0111_0001   71    MOV B, 1      ; B = 1 (F0)
    2      0100_0000   40    MOV B, A      ; temp = B; B = A
    ; Can't do: A = A + temp
    ; TD4 limitation: can only add IMMEDIATE to register, not register to register!
```

**This reveals TD4's fundamental limitation**: No register-to-register addition. The only way to add A and B is to use IN port or Immediate values!

### Program 6: Practical LED Chaser

```
; "Knight Rider" style LED pattern: 1-2-4-8-4-2-1-2-4-8-...
    0      1011_0001   B1    OUT 1         ; 0001
    1      1011_0010   B2    OUT 2         ; 0010
    2      1011_0100   B4    OUT 4         ; 0100
    3      1011_1000   B8    OUT 8         ; 1000
    4      1011_0100   B4    OUT 4         ; 0100
    5      1011_0010   B2    OUT 2         ; 0010
    6      1111_0000   F0    JMP 0         ; Loop
```

---

## 12. Extensions and Modifications

### 12.1 Adding Subtraction

TD4 can only add. To subtract, use two's complement:

```
A - B = A + (~B + 1)

Example: 7 - 3
  7 = 0111
  3 = 0011
 ~3 = 1100
~3+1= 1101 (which is -3 in two's complement)
7 + (-3) = 0111 + 1101 = 10100 â†’ 0100 = 4 âœ“
```

But TD4 can't compute ~B easily without hardware mods. 

**Hardware modification**: Add XOR gates before ALU B-input, controlled by a SUB signal.

### 12.2 Expanding to 8-bit

To make an 8-bit version:
- Replace 74HC283 with two cascaded 74HC283s (or one 74HC283 + 74HC283)
- Double all register widths
- Expand MUX to 8-bit wide
- Expand ROM data width to 12 bits (4 opcode + 8 immediate)

### 12.3 Adding More Instructions

Current unused opcodes (8, A, C, D) could implement:
- **NOP**: No operation (useful for timing)
- **AND**: Logical AND (needs new ALU hardware)
- **NOT**: Bitwise invert A
- **SHL**: Shift left (multiply by 2)

### 12.4 Memory for Data (RAM)

TD4 has no RAMâ€”only ROM for instructions. To add data memory:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   TD4 + RAM                   â”‚
â”‚                                               â”‚
â”‚  ROM (instructions) â—„â”€â”€â”€â”€ PC                  â”‚
â”‚          â”‚                                    â”‚
â”‚          â–¼                                    â”‚
â”‚       Decoder                                 â”‚
â”‚          â”‚                                    â”‚
â”‚          â–¼                                    â”‚
â”‚  RAM (data) â—„â”€â”€â”€â”€â”€â”€â”€ Address from instruction â”‚
â”‚      â–²   â”‚                                    â”‚
â”‚      â”‚   â–¼                                    â”‚
â”‚      â””â”€ ALU â—„â”€â”€â”€â”€ Registers                   â”‚
â”‚                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

New instructions needed:
- **LOAD addr**: A â† RAM[addr]
- **STORE addr**: RAM[addr] â† A

### 12.5 Stack and Subroutines

For CALL/RET functionality:
1. Add a stack pointer register (SP)
2. Add RAM for stack storage
3. Implement PUSH, POP, CALL, RET

This significantly increases complexity but enables recursion!

---

## Appendix A: Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TD4 QUICK REFERENCE                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  REGISTERS                                                   â”‚
â”‚    A, B    : 4-bit general purpose                          â”‚
â”‚    OUT     : 4-bit output port                              â”‚
â”‚    PC      : 4-bit program counter (0-15)                   â”‚
â”‚    C       : 1-bit carry flag                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  INSTRUCTION FORMAT                                          â”‚
â”‚    [OPCODE:4][IMMEDIATE:4]                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  OPCODE  MNEMONIC      OPERATION                            â”‚
â”‚    0     ADD A, Im     A â† A + Im                           â”‚
â”‚    1     MOV A, B      A â† B                                â”‚
â”‚    2     IN A          A â† Input Port                       â”‚
â”‚    3     MOV A, Im     A â† Im                               â”‚
â”‚    4     MOV B, A      B â† A                                â”‚
â”‚    5     ADD B, Im     B â† B + Im                           â”‚
â”‚    6     IN B          B â† Input Port                       â”‚
â”‚    7     MOV B, Im     B â† Im                               â”‚
â”‚    9     OUT B         Output â† B                           â”‚
â”‚    B     OUT Im        Output â† Im                          â”‚
â”‚    E     JNC Im        if C=0: PC â† Im                      â”‚
â”‚    F     JMP Im        PC â† Im                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UNUSED OPCODES: 8, A, C, D                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Appendix B: Comparison with Other Educational CPUs

| Feature | TD4 | SAP-1 | HACK | 6502 |
|---------|-----|-------|------|------|
| Data width | 4-bit | 8-bit | 16-bit | 8-bit |
| Address space | 16 bytes | 16 bytes | 32KÃ—2 | 64KB |
| Registers | 2 GP + OUT | 1 (A) | 2 (A,D) | 3 (A,X,Y) |
| Instructions | 12 | 5 | ~28 | 56 |
| ALU operations | ADD only | ADD, SUB | ADD, AND, NOT | Full |
| RAM | No | No | 16K | Yes |
| Stack | No | No | Call stack | Yes |
| IC count | ~10 | ~15 | ~25 | 1 |
| Clock cycles/instr | 1 | 6 | 1-2 | 2-7 |

---

## Appendix C: Troubleshooting Guide

| Symptom | Possible Cause | Solution |
|---------|---------------|----------|
| Nothing works | Power not connected | Check VCC and GND |
| Random behavior | Missing decoupling caps | Add 0.1ÂµF near each IC |
| PC doesn't count | Clock not reaching 161 | Check CLK wiring |
| Wrong instruction | ROM programmed incorrectly | Verify ROM contents |
| Carry always 0/1 | Carry FF not connected | Check 74HC74 wiring |
| Jump doesn't work | LOAD not reaching PC | Trace decoder output |
| Output stuck | OUT register not loading | Check LOAD_OUT signal |

---

## Conclusion

The TD4 is a masterpiece of minimalist design. With just 10 ICs, it demonstrates:

1. **Fetch-Decode-Execute cycle** in hardware
2. **Stored-program architecture** (von Neumann concept)
3. **Control signal generation** from opcodes
4. **Conditional branching** with flags
5. **Register transfer** operations

Building and understanding the TD4 gives you intuition that transfers directly to understanding real CPUsâ€”you'll never look at a computer the same way again.

**Suggested next steps after TD4:**
1. Build it on a breadboard
2. Write several programs
3. Add hardware modifications
4. Move to 8-bit (SAP-1 or similar)
5. Study the HACK computer (Nand2Tetris)
6. Explore real vintage CPUs (6502, Z80)

Happy building! ğŸ”§
