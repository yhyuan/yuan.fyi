---
title: Pattern 1 Binary Search
date: "2024-05-21"
tags: ["leetcode", "pattern"]
draft: false
images: ['/static/images/canada/mountains.jpg']
---

### Introduction
Binary search is one of the most elegant and efficient algorithms in computer science, renowned for its simplicity and speed. This algorithm is a staple in many programming challenges and interviews due to its effectiveness in searching sorted data. In this blog post, we’ll dive into the core principles of binary search, explore how it works, and examine some practical use cases and variations.

The traditional binary search is an algorithm that finds the position of a target value within a sorted array or list. It operates by repeatedly dividing the search interval in half. If the target value is less than the value in the middle of the interval, it narrows the search to the lower half. If the target value is greater, it narrows the search to the upper half. This process continues until the target value is found or the search interval is empty.

This method can be extended to more general cases. Initially, we identify the search range, which is defined by a minimal and a maximal value. In a standard binary search, this range is typically from 0 to the length of the array minus 1. We also recognize that within this range, there exists a boundary: to the left of the boundary, a certain condition is not satisfied, while to the right of the boundary, the condition is met.

In the context of traditional binary search, the condition usually involves finding values in a sorted array that are greater than or equal to a target value. If a problem conforms to this type of condition, it can be effectively solved using a general binary search approach.

The key to solve these problems is to identify the low and high boundary and the condition to decide the boundary.

Here are the code template for Python and TypeScript.

Python Template
```Python
def search(nums: List[int], target: int):
    lo, hi = ....... # TBD
    condition = lambda mid: ...... # TBD
    while lo < hi:
        mid = (lo + hi) // 2
        # const mid = (lo + hi) >> 1;
        if condition(mid):
            hi = mid
        else:
            lo = mid + 1
    return lo
```

TypeScript Template
```TypeScript
function search(nums: number[], target: number): number {
    const condition = (mid: number): boolean => .......; // TBD
    let [lo, hi] = .......; // TBD
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    if (nums[lo] === target) return lo;
    return -1;
};
```

<TOCInline toc={props.toc} exclude="Introduction" />

### Questions

#### 704.Binary Search[easy]

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

Solution:
The search range is between 0 and the length of sorted array and we can divided the search range into two parts. In the left part, the values are less than the target and in the right part, the values are greater or equal to the target. After we cand find the boundary, we can test whether the related value is target or not.

```Python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        lo, hi = 0, len(nums)
        condition = lambda mid: nums[mid] >= target
        while lo < hi:
            mid = (lo + hi) // 2
            # const mid = (lo + hi) >> 1;
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        if lo < len(nums) and nums[lo] == target:
            return lo
        return -1
```

```TypeScript
function search(nums: number[], target: number): number {
    // Find the most left postion, whose value meets the condition.
    const condition = (mid: number): boolean => nums[mid] >= target;
    let [lo, hi] = [0, nums.length];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    if (nums[lo] === target) return lo;
    return -1;
};
```
#### 35.Search Insert Position[easy]

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

Solution: Similar to 704.Binary Search[easy], we can solve it by find the boundary between the values less than the target and the values equal to or greater than the target.

```Python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        lo, hi = 0, len(nums)
        condition = lambda mid: nums[mid] >= target
        while lo < hi:
            mid = (lo + hi) // 2
            # const mid = (lo + hi) >> 1;
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo
```

```TypeScript
function searchInsert(nums: number[], target: number): number {
    const condition = (mid: number): boolean => nums[mid] >= target;
    let [lo, hi] = [0, nums.length];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
};
```

#### 744.Find Smallest Letter Greater Than Target[easy]

You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.

Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.

Solution: we can solve it by find the boundary between the values equal to or less than the target and the values greater than the target.

Here's a rewritten version of the text:

**Solution:** This problem can be efficiently solved by employing a binary search approach to locate a specific boundary within the array. Our goal is to identify the dividing line between two groups of values:
1. Values that are equal to or less than the target
2. Values that are strictly greater than the target

```Python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        lo, hi = 0, len(letters)
        condition = lambda mid: letters[mid] > target
        while lo < hi:
            mid = (lo + hi) // 2
            # const mid = (lo + hi) >> 1;
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        if lo == len(letters):
            return letters[0]
        return letters[lo]
```

```TypeScript
function nextGreatestLetter(letters: string[], target: string): string {
    // const condition = (mid: number): boolean => letters[mid].charCodeAt(0) > target.charCodeAt(0);
    const condition = (mid: number): boolean => letters[mid] > target;
    let [lo, hi] = [0, letters.length];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    if (lo === letters.length) return letters[0];
    return letters[lo];
};
```

#### 34.Find First and Last Position of Element in Sorted Array[medium]

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

**Solution:** We can approach this problem by identifying two crucial boundaries:

The first boundary separates values less than the target from those equal to or greater than the target.
The second boundary distinguishes between values equal to or less than the target and those greater than the target.

To find the range of the target element, we need to locate both these boundaries. The first boundary represents the starting position of the target element (if it exists in the array). The second boundary, when decreased by 1, gives us the ending position of the target element.
By using a binary search algorithm twice - once for each boundary - we can efficiently pinpoint these positions. This approach allows us to handle cases where the target appears multiple times in the array, as well as when it's not present at all.

```Python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def solver(condition):
            lo, hi = 0, len(nums)
            while lo < hi:
                mid = (lo + hi) // 2
                # const mid = (lo + hi) >> 1;
                if condition(mid):
                    hi = mid
                else:
                    lo = mid + 1
            return lo

        left_index = solver(lambda mid: nums[mid] >= target)
        right_index = solver(lambda mid: nums[mid] > target) - 1

        # Check if the target is present at the found indices
        if left_index < len(nums) and nums[left_index] == target:
            return [left_index, right_index]
        else:
            return [-1, -1]
```

```TypeScript
function searchRange(nums: number[], target: number): number[] {
    const conditionFirst = (mid: number): boolean => nums[mid] >= target;
    const conditionLast = (mid: number): boolean => nums[mid] > target;
    const solver = (condition: (mid: number) => boolean): number => {
        let [lo, hi] = [0, nums.length];
        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (condition(mid)) {
                hi = mid;
            } else {
                lo = lo + 1;
            }
        }
        return lo;
    }
    const low = solver(conditionFirst);
    const high = solver(conditionLast) - 1;
    if (nums[low] !== target) return [-1, -1];
    return [low, high];
};
```

#### 702.Search in a Sorted Array of Unknown Size[medium]

This is an interactive problem.

You have a sorted array of unique elements and an unknown size. You do not have an access to the array but you can use the ArrayReader interface to access it. You can call ArrayReader.get(i) that:

returns the value at the ith index (0-indexed) of the secret array (i.e., secret[i]), or
returns 231 - 1 if the i is out of the boundary of the array.
You are also given an integer target.

Return the index k of the hidden array where secret[k] == target or return -1 otherwise.

You must write an algorithm with O(log n) runtime complexity.

**Solution:** This problem can be approached in a manner similar to "704. Binary Search" [Easy]. Our objective is to identify the boundary between two groups of values: those less than the target, and those equal to or greater than the target.
We can employ a binary search algorithm to efficiently locate this boundary. The search range for this problem is between 0 and 10001 (10000 + 1). By using binary search, we can quickly narrow down this range to find the precise point where values transition from being less than the target to being equal to or greater than it.

```Python
class Solution:
    def search(self, reader: 'ArrayReader', target: int) -> int:
        lo, hi = 0, 10000 + 1
        condition = lambda mid: reader.get(mid) >= target
        while lo < hi:
            mid = (lo + hi) // 2
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        return -1 if reader.get(lo) != target else lo
```

```TypeScript
function search(reader: ArrayReader, target: number): number {
	let [lo, hi] = [0, 10**4 + 1];
    const condition = (mid: number): boolean => reader.get(mid) >= target;
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = lo + 1;
        }
    }
    if (reader.get(lo) === target) return lo;
    return -1;
};
```

#### 69. Sqrt(x)[Easy]

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x \*\* 0.5 in python.

**Solution:** This problem can be approached similarly to the "704. Binary Search" [Easy] problem. Our goal is to identify the boundary between two sets of values: those whose squares are less than or equal to the target, and those whose squares exceed the target. This boundary will lie somewhere between 0 and x + 1.
We can use a binary search algorithm to efficiently locate this boundary. By doing so, we're essentially finding the largest integer whose square doesn't surpass the target value. This method allows us to narrow down the search range quickly, making it an optimal solution for this problem.

```Python
class Solution:
    def mySqrt(self, x: int) -> int:
        lo, hi = 0, x + 1 #
        condition = lambda mid: mid * mid > x
        while lo < hi:
            mid = (lo + hi) // 2
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo - 1 # lo is the most left value which meet mid * mid > x.

```

```TypeScript
function mySqrt(x: number): number {
    if (x <= 1 ) return x;
    // Find the minimal integer whose square is greater than x.
    const condition = (mid: number): boolean => mid * mid > x;
    let [lo, hi] = [0, x];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo - 1;
};
```

#### 367. Valid Perfect Square[Easy]

Given a positive integer num, return true if num is a perfect square or false otherwise.

A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.

You must not use any built-in library function, such as sqrt.

**Solution:** Similar to "Sqrt(x)" (LeetCode problem 69), we find the square root of the number and then check if it forms a valid perfect square.

```TypeScript
function isPerfectSquare(num: number): boolean {
    const sqrt = mySqrt(num); // 69. Sqrt(x)[Easy]
    return sqrt * sqrt === num;
};
```

#### 278. First Bad Version[Easy]

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

**Solution:** The range is between 1 and n + 1, and we can use the `isBadVersion` function to find the point where the transition occurs from false to true.

```Python
class Solution:
    def firstBadVersion(self, n: int) -> int:
        lo, hi = 1, n + 1
        while lo < hi:
            mid = (lo + hi) // 2
            if isBadVersion(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo
```
```TypeScript
var solution = function(isBadVersion: any) {
    return function(n: number): number {
        let [lo, hi] = [1, n + 1];
        // const condition = (mid: number): boolean => isBadVersion(mid);
        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (isBadVersion(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    };
};
```
#### 74. Search a 2D Matrix[Medium]

You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m \* n)) time complexity.

**Solution:** This problem is similar to other binary search questions. The main difference is that we need to convert the middle index into a row and column index within the matrix.

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        rows, cols = len(matrix), len(matrix[0])
        lo, hi = 0, rows * cols
        condition = lambda mid: matrix[mid // cols][ mid % cols] >= target
        while lo < hi:
            mid = (lo + hi) // 2
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo < rows * cols and matrix[lo // cols][ lo % cols] == target
```

```TypeScript
function searchMatrix(matrix: number[][], target: number): boolean {
    const m = matrix.length;
    const n = matrix[0].length;
    let [lo, hi] = [0, m * n];
    const condition = (mid: number): boolean => {
        const row = Math.floor(mid / n);
        const col = mid % n;
        return matrix[row][col] >= target;
    };
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    if (lo === m * n) return false;
    const row = Math.floor(lo / n);
    const col = lo % n;
    return matrix[row][col] === target;
};
```

#### 240. Search a 2D Matrix II[Medium]

Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.


```TypeScript
function searchMatrix(matrix: number[][], target: number): boolean {
    const m = matrix.length;
    const n = matrix[0].length;
    // Top Right corn. It has the largest value in its row and has the smallest value in its column.
    // If the target value is equal to the value in top right corner, return true;
    // If the target value is greater than the value in top right corner,
    // it means all values in this row is less than the target value; So all of them can be removed from search area.
    // If the target value is smalelr than the value in top right corner,
    // it means all values in this column are greater than the target value. So all them can be removed from search area.
    // O(max(m, n))
    let row = 0;
    let col = n - 1;
    while (row < m && col >= 0) {
        if (matrix[row][col] === target) return true;
        if (matrix[row][col] < target) {
            row += 1;
        } else {
            col -= 1;
        }
    }
    return false;
};
```

#### 162. Find Peak Element[Medium]

A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

**Solution:** A peak is the leftmost value in a non-increasing sequence. We can identify this boundary using the condition `condition = lambda mid: mid == len(nums) - 1 or nums[mid] >= nums[mid + 1]`. This condition helps us find the peak by checking if the current value is greater than or equal to the next value, or if it is the last element in the array.


```Python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        lo, hi = 0, len(nums)
        # Find the most left down slope.
        condition = lambda mid: mid == len(nums) - 1 or nums[mid] >= nums[mid + 1]
        while lo < hi:
            mid = (lo + hi) // 2
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo
```

```TypeScript
function findPeakElement(nums: number[]): number {
    let [lo, hi] = [0, nums.length];
    // The peak is the leftest side of a decresing trend.
    const condition = (mid: number): boolean => mid === nums.length - 1 || nums[mid] > nums[mid + 1];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
};
```

#### 33.Search in Rotated Sorted Array[Medium]

There is an integer array nums sorted in ascending order (with _distinct_ values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (`1 <= k < nums.length`) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

**Solution:** The solution involves two steps. In the first step, we use binary search to find the index of the minimum value. In the second step, we use this index as a shift to locate the target.

For the first step, the boundary is defined where values on the left side are always greater than or equal to `nums[0]`, and values on the right side are always less than `nums[0]`. (The boundary can also be defined as where values on the left side are always greater than or equal to `nums[nums.length - 1]`, and values on the right side are always less than `nums[nums.length - 1]`.)

In the second step, we adjust for the shift by adding it to the index when searching for the target.

```TypeScript
function search(nums: number[], target: number): number {
    function findMinIndex(nums: number[]): number {
        // Find the valley: the leftest side of the value which is smaller than nums[0].
        let [lo, hi] = [0, nums.length];
        const condition = (mid: number): boolean => {
            return nums[mid] < nums[0];
        };
        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (condition(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    };
    const n = nums.length;
    const minIndex = findMinIndex(nums);
    const condition = (mid: number): boolean => nums[mid % n] >= target;
    let [lo, hi] = [minIndex, minIndex + n];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return nums[lo % n] === target ? lo % n : -1;
};
```

#### 81.Search in Rotated Sorted Array II[Medium]

There is an integer array nums sorted in non-decreasing order (**not necessarily with distinct values**).

Before being passed to your function, nums is rotated at an unknown pivot index k (`0 <= k < nums.length`) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].

Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.

You must decrease the overall operation steps as much as possible.

**Solution:** Similar to "Search in Rotated Sorted Array" (LeetCode problem 33), we can find the solution in two steps. First, we locate the index of the minimum value, and second, we use this index as a shift to find the target.

In the first step, we address the edge case where the first and last values are the same. We increment the `low` pointer until we reach a value different from the first (or last) value. If no different value is found, it means all the values are the same, and we can simply check if this value equals the target. If a different value is found, we look for the leftmost index of the values that are less than or equal to the last value.

In the second step, we use the index found in the first step as an index shift to locate the target.

```TypeScript
// Relate to 154.Find Minimum in Rotated Sorted Array II

function search(nums: number[], target: number): boolean {
    function findMinIndex(nums: number[]): number {
        const n = nums.length;
        let [lo, hi] = [0, n];
        if (nums[0] === nums[n - 1]) {
            // Increase lo until it is different from nums[n - 1]
            while (lo < n && nums[lo] === nums[0]) {
                lo += 1;
            }
            // All same values
            if (lo === n) return -1;
        }
        // The valley is the leftest side of the value less than last value.
        const condition = (mid: number): boolean => nums[mid] <= nums[n - 1];
        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (condition(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    };
    const n = nums.length;
    const minIndex = findMinIndex(nums);
    // All same values
    if (minIndex === -1) return target === nums[0];
    const condition = (mid: number): boolean => nums[mid % n] >= target;
    let [lo, hi] = [minIndex, minIndex + n];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return nums[lo % n] === target;
};
```

#### 153.Find Minimum in Rotated Sorted Array[Medium]

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

**Solution:** The array can be divided into two parts: the left side, where the elements are greater than the last value, and the right side, where the elements are less than or equal to the last value. The boundary between these two parts is the index of the minimum value in the array.

```TypeScript
function findMin(nums: number[]): number {
    let [lo, hi] = [0, nums.length];
    // The valley is the leftest side of the value less than last value.
    const condition = (mid: number): boolean => nums[mid] <= nums[nums.length - 1];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return nums[lo];
};
```

#### 154.Find Minimum in Rotated Sorted Array II

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:

[4,5,6,7,0,1,4] if it was rotated 4 times.
[0,1,4,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.

You must decrease the overall operation steps as much as possible.

**Solution:** As discussed in "Search in Rotated Sorted Array II" (LeetCode problem 81), there's an edge case where the first value is the same as the last value. To handle this, we can increment the `low` pointer until it points to a value different from the first (or last) value. If we cannot find a different value, it means all the values in the array are the same.

Once we find a different value, we can try to locate the leftmost index of the values that are less than or equal to the last value.

```TypeScript
function findMin(nums: number[]): number {
    const n = nums.length;
    let [lo, hi] = [0, n];

    if (nums[0] === nums[n - 1]) {
        // Increase lo until it is different from nums[n - 1]
        while (lo < n && nums[lo] === nums[0]) {
            lo += 1;
        }
        // All same values
        if (lo === n) return nums[0];
    }

    // The valley is the leftest side of the value less than last value.
    const condition = (mid: number): boolean => nums[mid] <= nums[n - 1];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return nums[lo];
};
```

#### 275. H-Index II

Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in ascending order, return the researcher's h-index.

According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.

You must write an algorithm that runs in logarithmic time.

```TypeScript
function hIndex(citations: number[]): number {
    // Find the min (the leftist) index that citations[i] >= n - 1 - i + 1
    const n = citations.length;
    let [lo, hi] = [0, n];
    const condition = (mid: number): boolean => citations[mid] >= n - 1 - mid + 1;
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return n - 1 - lo + 1;
};
```

#### 1011. Capacity To Ship Packages Within D Days

A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.

```TypeScript
function shipWithinDays(weights: number[], days: number): number {
    const n = weights.length;
    // Find the min capacity which can ship all weights within days.
    const maxWeight = Math.max(...weights); // Ship with weights.length days
    const totalWeight = weights.reduce((acc, cur) => acc + cur, 0); // Ship it with one day
    let [lo, hi] = [maxWeight, totalWeight + 1];
    const condition = (mid: number): boolean => {
        let count = 0;
        let total = 0;
        weights.forEach(weight => {
            total += weight;
            if (total > mid) {
                total = weight;
                count += 1;
            }
        });
        if (total > 0) {
            count += 1;
        }
        return count <= days;
    };
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (condition(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
};
```

#### 410. Split Array Largest Sum

Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.

Return the minimized largest sum of the split.

A subarray is a contiguous part of the array.


```TypeScript
// As same as 1011. Capacity To Ship Packages Within D Days
```

#### 875. Koko Eating Bananas

Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.

Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return the minimum integer k such that she can eat all the bananas within h hours.

```TypeScript
function minEatingSpeed(piles: number[], h: number): number {
    let [lo, hi] = [1, Math.max(...piles)];
    const feasible = (mid: number): boolean => {
        const hours = piles.map(pile => Math.ceil(pile / mid))
                           .reduce((acc, cur) => acc + cur, 0);
        return hours <= h;
    };
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (feasible(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
};
```

#### 1482. Minimum Number of Days to Make m Bouquets

You are given an integer array bloomDay, an integer m and an integer k.

You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.

The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.

```TypeScript
function minDays(bloomDay: number[], m: number, k: number): number {
    const n = bloomDay.length;
    if (n < m * k) return -1;
    const feasible = (mid: number): boolean => {
        let count = 0;
        let cur = 0;
        bloomDay.forEach(day => {
            if (day <= mid) {
                cur += 1;
                if (cur === k) {
                    cur = 0;
                    count += 1;
                }
            } else {
                cur = 0;
            }
        });
        return count >= m;
    };
    let [lo, hi] = [1, Math.max(...bloomDay) + 1];
    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (feasible(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
};
```

#### 668. Kth Smallest Number in Multiplication Table

Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (1-indexed).

Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.

Explain:
In order to find the k-th smallest value in the table, we can design an `enough` function, given an input num, determine whether there're at least k values less than or equal to num. **The minimal num satisfying enough function is the answer we're looking for.**

```TypeScript
function findKthNumber(m: number, n: number, k: number): number {
        const feasible = (x: number): boolean => {
            let count = 0;
            for (let i = 1; i <= m; i++) {
                // Each row either has n elements or x // i elements
                count += Math.min(Math.floor(x / i), n);
            }
            return count >= k;
        };

        let [lo, hi] = [1, m * n];

        while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (feasible(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }

        return lo;
};
```

#### 719. Find K-th Smallest Pair Distance

The distance of a pair of integers a and b is defined as the absolute difference between a and b.

Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where `0 <= i < j < nums.length`.

Explain
We can design an enough function, given an input distance, determine whether there're at least k pairs whose distances are less than or equal to distance.

```TypeScript
function smallestDistancePair(nums: number[], k: number): number {
    const enough = (distance: number): boolean => {  // two pointers
        let count = 0, i = 0, j = 0;
        while (i < n || j < n) {
            while (j < n && nums[j] - nums[i] <= distance) {  // move fast pointer
                j++;
            }
            count += j - i - 1;  // count pairs
            i++;  // move slow pointer
        }
        return count >= k;
    };

    nums.sort((a, b) => a - b);  // TypeScript sort needs a comparison function
    const n = nums.length;
    let lo = 0, hi = nums[n - 1] - nums[0];

    while (lo < hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (enough(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }

    return lo;
};
```

#### 1201. Ugly Number III

An ugly number is a positive integer that is divisible by a, b, or c.

Given four integers n, a, b, and c, return the nth ugly number.

```TypeScript
function nthUglyNumber(n: number, a: number, b: number, c: number): number {
    function gcd(x: number, y: number): number {
        while (y !== 0) {
            let temp = y;
            y = x % y;
            x = temp;
        }
        return x;
    }

    const ab = a * b / gcd(a, b);
    const ac = a * c / gcd(a, c);
    const bc = b * c / gcd(b, c);
    const abc = a * bc / gcd(a, bc);

    function enough(num: number): boolean {
        const total = Math.floor(num / a) + Math.floor(num / b) + Math.floor(num / c)
                     - Math.floor(num / ab) - Math.floor(num / ac) - Math.floor(num / bc)
                     + Math.floor(num / abc);
        return total >= n;
    }

    let left = 1;
    let right = 10 ** 10;

    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        if (enough(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
};
```

#### 1283. Find the Smallest Divisor Given a Threshold

Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.

Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).

The test cases are generated so that there will be an answer.

```python
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        def enough(mid):
            ans = 0
            for num in nums:
                if num % mid == 0:
                    ans += num // mid
                else:
                    ans += num // mid
                    ans += 1
            return ans <= threshold
        lo, hi = 1, max(nums)
        while lo < hi:
            mid = (lo + hi) // 2
            if enough(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo
```

#### 222. Count Complete Tree Nodes

Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.


```python
# 2. bisect_left variant
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def countNodes(root: TreeNode) -> int:
    if not root:
        return 0

    # Function to compute the height of the tree
    def get_height(node):
        height = 0
        while node.left:
            height += 1
            node = node.left
        return height

    # Check if a node exists at idx (0-indexed) in the last level
    def exists(idx, height, node):
        left, right = 0, 2 ** height - 1
        for _ in range(height):
            mid = (left + right) // 2
            if idx <= mid:
                node = node.left
                right = mid
            else:
                node = node.right
                left = mid + 1
        return node is not None

    height = get_height(root)
    if height == 0:
        return 1

    # Binary search to find the number of nodes on the last level
    # Binary search to find the number of nodes on the last level
    left, right = 0, 2 ** height
    dropLeftPart = lambda mid: exists(mid, height, root)
    while left < right:
        mid = (left + right) // 2
        if dropLeftPart(mid):
            left = mid + 1
        else:
            right = mid

    # Total nodes = all nodes above the last level + nodes on the last level
    return (2 ** height - 1) + left
# Example usage:
# Constructing a complete binary tree [1, 2, 3, 4, 5, 6]
#          1
#        /   \
#       2     3
#      / \   /
#     4   5 6

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
root.right.left = TreeNode(6)

print(countNodes(root))  # Output: 6
```

1. **Calculate the tree height**:

   - Move to the leftmost path of the tree to determine the height `h` of the tree.

2. **Binary Search on the Last Level**:
   - Use binary search to count the number of nodes in the last level.
   - For a complete binary tree, the last level may not be completely filled. The nodes in the last level are numbered from `0` to `2^h - 1`.
   - Perform a binary search on the index range `[0, 2^h - 1]` to determine how many nodes exist on the last level.

#### 378. Kth Smallest Element in a Sorted Matrix

Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

You must find a solution with a memory complexity better than O(n2).

Follow up:

Could you solve the problem with a constant memory (i.e., O(1) memory complexity)?
Could you solve the problem in O(n) time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)

        def countLessEqual(x):
            # Function to count the number of elements less than or equal to x
            count = 0
            row, col = n - 1, 0
            while row >= 0 and col < n:
                if matrix[row][col] <= x:
                    count += (row + 1)
                    col += 1
                else:
                    row -= 1
            return count

        left, right = matrix[0][0], matrix[-1][-1]
        while left < right:
            mid = (left + right) // 2
            if countLessEqual(mid) < k:
                left = mid + 1
            else:
                right = mid

        return left
```

#### 2187. Minimum Time to Complete Trips

You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.

Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.

You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.

```python
class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        def trips_completed_by_time(T):
            # Calculate the total number of trips all buses can make by time T
            return sum(T // t for t in time)

        # Set initial bounds for binary search
        low, high = 1, max(time) * totalTrips

        while low < high:
            mid = (low + high) // 2
            if trips_completed_by_time(mid) >= totalTrips:
                high = mid  # try for a smaller time
            else:
                low = mid + 1  # need more time

        return low
```

#### 1060. Missing Element in Sorted Array

Given an integer array nums which is sorted in ascending order and all of its elements are unique and given also an integer k, return the kth missing number starting from the leftmost number of the array.

Follow up: Can you find a logarithmic time complexity (i.e., O(log(n))) solution?

```python
class Solution:
    def missingElement(self, nums: List[int], k: int) -> int:
        def missing_count(index):
            # Number of missing elements until nums[index]
            return nums[index] - nums[0] - index

        n = len(nums)

        # If k missing numbers are beyond the last element in nums
        if k > missing_count(n - 1):
            return nums[-1] + k - missing_count(n - 1)

        left, right = 0, n - 1

        # Binary search to find the position where the kth missing number should be
        while left < right:
            mid = (left + right) // 2
            if missing_count(mid) < k:
                left = mid + 1
            else:
                right = mid

        # Find the exact kth missing number
        return nums[left - 1] + k - missing_count(left - 1)
```

#### 1891. Cutting Ribbons

You are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon, and an integer k. You may cut any of the ribbons into any number of segments of positive integer lengths, or perform no cuts at all.

For example, if you have a ribbon of length 4, you can:
Keep the ribbon of length 4,
Cut it into one ribbon of length 3 and one ribbon of length 1,
Cut it into two ribbons of length 2,
Cut it into one ribbon of length 2 and two ribbons of length 1, or
Cut it into four ribbons of length 1.
Your goal is to obtain k ribbons of all the same positive integer length. You are allowed to throw away any excess ribbon as a result of cutting.

Return the maximum possible positive integer length that you can obtain k ribbons of, or 0 if you cannot obtain k ribbons of the same length.

```python
class Solution:
    def maxLength(self, ribbons: List[int], k: int) -> int:
        def canCutRibbons(length):
            count = 0
            for ribbon in ribbons:
                count += ribbon // length
            return count

        left, right = 1, max(ribbons)
        best_length = 0

        while left <= right:
            mid = (left + right) // 2
            if canCutRibbons(mid) >= k:
                best_length = mid
                left = mid + 1
            else:
                right = mid - 1

        return best_length
```

#### 540. Single Element in a Sorted Array

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return the single element that appears only once.

Your solution must run in O(log n) time and O(1) space.

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            if mid % 2 == 1:
                mid -= 1  # Ensure mid is even

            if nums[mid] == nums[mid + 1]:
                left = mid + 2
            else:
                right = mid

        return nums[left]
```

#### 374. Guess Number Higher or Lower

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.


```python
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -> int:

class Solution:
    def guessNumber(self, n: int) -> int:
        lo = 1
        hi = n
        # Your guess is higher than or equal to the number I picked (i.e. num >= pick).
        condition = lambda mid: guess(mid) <= 0
        while lo < hi:
            mid = (lo + hi) // 2
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        return lo
```

#### 270. Closest Binary Search Tree Value

Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest.


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -> int:
        def helper(root):
            if root == None:
                return []
            return helper(root.left) + [root.val] + helper(root.right)
        nums = helper(root)
        lo = 0
        hi = len(nums)
        condition = lambda mid: nums[mid] > target
        while lo < hi:
            mid = (lo + hi) // 2
            if condition(mid):
                hi = mid
            else:
                lo = mid + 1
        if lo == 0:
            return nums[lo]
        if lo == len(nums):
            return nums[len(nums) - 1]
        diff1 = abs(nums[lo] - target)
        diff2 = abs(nums[lo - 1] - target)
        if diff1 < diff2:
            return nums[lo]
        return nums[lo - 1]
```

#### 1539.Kth Missing Positive Numnber

Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.

Return the kth positive integer that is missing from this array.

```Python
class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        left, right = 0, len(arr) - 1

        # Binary search to find the smallest index where the missing count >= k
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] - (mid + 1) < k:
                left = mid + 1
            else:
                right = mid - 1

        # If left is greater than the size of the array, calculate the kth missing number directly
        if left == len(arr):
            return arr[-1] + (k - (arr[-1] - len(arr)))

        # Otherwise, calculate the kth missing number within the array bounds
        return left + k
```


### Reference

https://towardsdatascience.com/powerful-ultimate-binary-search-template-and-many-leetcode-problems-1f850ef95651
