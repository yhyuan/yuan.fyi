---
title: BigFrontEnd Category 17 String Implementation Questions
date: "2024-06-14"
tags: ["BigFrontEnd", "category"]
draft: false
---
### Introduction

This blog post summarizes the String implementation related questions found on BigFrontEnd.Dev.

<TOCInline toc={props.toc} exclude="Introduction" />

### 1.convert HEX color to RGBA

78.https://bigfrontend.dev/problem/convert-HEX-color-to-RGBA

```js
/**
 * @param {string} hex
 * @return {string}
 */
function hexToRgba(hex) {
  // Helper function to validate the hex color input
  function isValidHex(hex) {
    return /^#([0-9A-Fa-f]{3,4}|[0-9A-Fa-f]{6,8})$/.test(hex);
  }

  // Helper function to expand shorthand hex notation to full form
  function expandShorthand(hex) {
    if (hex.length === 4) {
      return "#" + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    if (hex.length === 5) {
      return (
        "#" +
        hex[1] +
        hex[1] +
        hex[2] +
        hex[2] +
        hex[3] +
        hex[3] +
        hex[4] +
        hex[4]
      );
    }
    return hex;
  }

  // Validate input
  if (!isValidHex(hex)) {
    throw new Error("Invalid hexadecimal color format");
  }

  // Expand shorthand notation if necessary
  hex = expandShorthand(hex);

  // Extract the red, green, blue, and alpha components
  let r = parseInt(hex.slice(1, 3), 16);
  let g = parseInt(hex.slice(3, 5), 16);
  let b = parseInt(hex.slice(5, 7), 16);
  let a = 1;

  if (hex.length === 9) {
    a = parseInt(hex.slice(7, 9), 16) / 255;
    a = Math.round(a * 100) / 100; // Round to two decimal places
  }

  return `rgba(${r},${g},${b},${a})`;
}
// Example usage:
console.log(hexToRgb("#fff")); // 'rgba(255,255,255,1)'
console.log(hexToRgb("#ffffff")); // 'rgba(255,255,255,1)'
console.log(hexToRgb("#ff00ff80")); // 'rgba(255,0,255,0.5)'
console.log(hexToRgb("#123")); // 'rgba(17,34,51,1)'
console.log(hexToRgb("#1234")); // 'rgba(17,34,51,0.27)'
```

### 2.convert snake_case to camelCase

79.https://bigfrontend.dev/problem/convert-snake_case-to-camelCase

```js
snakeToCamel("snake_case");
// 'snakeCase'
snakeToCamel("is_flag_on");
// 'isFlagOn'
snakeToCamel("is_IOS_or_Android");
// 'isIOSOrAndroid'
snakeToCamel("_first_underscore");
// '_firstUnderscore'
snakeToCamel("last_underscore_");
// 'lastUnderscore_'
snakeToCamel("_double__underscore_");
// '_double__underscore_'
```

Sliding window: `x_x` => `xX`;

```js
/**
 * @param {string} str
 * @return {string}
 */
function snakeToCamel(str) {
  const n = str.length;
  // n - 3, n - 2, n -1
  if (n === 0) {
    return str;
  }
  const ans = [str[0]];
  let i = 0;
  while (i < n - 2) {
    // conside i, i + 1, i + 2
    if (str[i] !== "_" && str[i + 1] === "_" && str[i + 2] !== "_") {
      ans.push(str[i + 2].toUpperCase());
      i += 2;
    } else {
      ans.push(str[i + 1]);
      i += 1;
    }
  }
  ans.push(str[n - 1]);
  return ans.join("");
}
```

### 3.decode message

9.https://bigfrontend.dev/problem/decode-message
State change function.

```js
/**
 * @param {string[][]} message
 * @return {string}
 */
function decode(message) {
  const result = [];
  let x = 0;
  let y = 0;
  let dir = "down";

  const nextState = (x, y, dir) => {
    if (dir === "down") {
      x++;
    } else {
      x--;
    }

    if (x === 0) {
      dir = "down";
    } else if (x === message.length - 1) {
      dir = "up";
    }

    y++;
    return [x, y, dir];
  };
  const isValidState = (x, y, dir) => message[x] && message[x][y];
  while (isValidState(x, y, dir)) {
    result.push(message[x][y]);
    [x, y, dir] = nextState(x, y, dir);
  }

  return result.join("");
}
```

### 4.longest substring with unique characters

87.https://bigfrontend.dev/problem/longest-substring-with-unique-characters

```js
/**
 * @param {string} str
 * @return {string}
 */
function longestUniqueSubstr(s) {
  const n = s.length;
  let i = 0;
  let j = 0;
  let ans = "";
  const freq = {};
  const meetCondition = (freq) => Math.max(...Object.values(freq)) < 2;
  while (i < n) {
    // Move the right index as far as possible until the condition is not met.
    while (i < n && meetCondition(freq)) {
      freq[s[i]] = (freq[s[i]] || 0) + 1;
      i += 1;
    }
    // [j, i - 2] is the range which meets the condtion.
    // freq contains the data from [j, i - 1]
    if (meetCondition(freq)) {
      // [j, i - 1] (freq) meet the condition
      if (ans.length < i - 1 - j + 1) {
        ans = s.substring(j, i);
      }
      break;
    } else {
      // [j, i - 2] meet the condition
      if (ans.length < i - 2 - j + 1) {
        ans = s.substring(j, i - 2 + 1);
      }
    }
    // move the left index as far as possible until the condition is met.
    while (!meetCondition(freq)) {
      freq[s[j]] -= 1;
      j += 1;
    }
  }
  return ans;
}
```

### 5.implement String.prototype.trim()

95.https://bigfrontend.dev/problem/implement-String-prototype-trim
`\u3000` and ` ` are the spaces.

```js
/**
 * @param {string} str
 * @return {string}
 */
function trim(str) {
  const n = str.length;
  const isWhiteSpace = (char) => char === " " || char === "\u3000";
  let i = 0;
  while (i < n && isWhiteSpace(str[i])) {
    i += 1;
  }
  // i is the first non-empty character.
  let j = n - 1;
  while (j >= 0 && isWhiteSpace(str[j])) {
    j -= 1;
  }
  // j is the last non-empty character.
  return str.slice(i, j + 1);
}
```

```js
/**
 * @param {string} str
 * @return {string}
 */
function trim(str) {
  return str.replace(/^[\s\u3000]+|[\s\u3000]+$/g, "");
}
```

### 6.compress a string

97.https://bigfrontend.dev/problem/compress-a-string

```js
compress("a"); // 'a'
compress("aa"); // 'a2'
compress("aaa"); // 'a3'
compress("aaab"); // 'a3b'
compress("aaabb"); // 'a3b2'
compress("aaabba"); // 'a3b2a'
```

Fixed size sliding window.

```js
function compress(str) {
  const n = str.length;
  if (n <= 1) return str;
  let count = 1;
  let ans = [];
  for (let i = 0; i < n - 1; i++) {
    // window i, i + 1
    if (str[i] === str[i + 1]) {
      count += 1;
    } else {
      // str[i] ends and str[i + 1] start
      ans.push(str[i]);
      if (count > 1) {
        ans.push(String(count));
      }
      count = 1;
    }
  }
  ans.push(str[n - 1]);
  if (count > 1) {
    ans.push(String(count));
  }
  return ans.join("");
}
```

```js
/**
 * @param {string} str
 * @return {string}
 */
function compress(str) {
  let ans = "";
  let pre = "";
  let count = 0;
  for (const char of str) {
    if (pre === "") {
      pre = char;
      count = 1;
    } else if (pre === char) {
      count += 1;
    } else {
      if (count === 1) {
        ans += pre;
      } else {
        ans += `${pre}${count}`;
      }
      pre = char;
      count = 1;
    }
  }
  if (count === 1) {
    ans += pre;
  } else {
    ans += `${pre}${count}`;
  }
  return ans;
}
```

### 7.validate an IP address

98.https://bigfrontend.dev/problem/validate-an-ip-address

```js
/**
 * @param {string} str
 * @return {boolean}
 */
function isValidIPv4(ip) {
  const ipv4Pattern =
    /^(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)){3}$/;
  return ipv4Pattern.test(ip);
}

function isValidIPv6(ip) {
  const ipv6Pattern = /^([0-9a-fA-F]{1,4})(:[0-9a-fA-F]{1,4}){7}$/;
  return ipv6Pattern.test(ip);
}

function isValidIP(ip) {
  return isValidIPv4(ip) || isValidIPv6(ip);
}
```

### 8.validate string of parentheses

102.https://bigfrontend.dev/problem/validate-parenthesis

```js
/**
 * @param {string} str
 * @return {boolean}
 */
function validate(str) {
  const stack = [];
  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (["{", "[", "("].includes(ch)) {
      stack.push(ch);
    } else {
      if (stack.length === 0) {
        return false;
      }
      const matched = `${stack.pop()}${ch}`;
      if (!["()", "[]", "{}"].includes(matched)) {
        return false;
      }
    }
  }
  return stack.length === 0;
}
```

### 9.find the first duplicate character in a string

105.https://bigfrontend.dev/problem/find-the-first-duplicate-character-in-a-string

```js
/**
 * @param {string} str
 * @return {string | null}
 */
function firstDuplicate(str) {
  const seen = new Set();
  for (const char of str) {
    if (seen.has(char)) {
      return char;
    }
    seen.add(char);
  }
  return null;
}
```

### 10.Count palindromic substrings

111.https://bigfrontend.dev/problem/Count-palindromic-substrings

```js
/**
 * @param {string} str
 * @return {number}
 */
function countPalindromicSubstr(str) {
  const n = str.length;
  if (n === 0) return 0;
  const memo = new Map();
  let count = 0;
  for (let i = 0; i < n; i++) {
    memo.set(`${i},${i}`, true);
    count += 1;
  }
  for (let i = 0; i < n - 1; i++) {
    memo.set(`${i},${i + 1}`, str[i] === str[i + 1]);
    if (str[i] === str[i + 1]) {
      count += 1;
    }
  }
  const helper = (i, j) => {
    const key = `${i},${j}`;
    if (memo.has(key)) {
      return memo.get(key);
    }
    const ans = str[i] === str[j] && helper(i + 1, j - 1);
    memo.set(key, ans);
    if (ans) {
      count += 1;
    }
    return ans;
  };
  for (let i = 0; i < n; i++) {
    for (j = i + 1; j < n; j++) {
      helper(i, j);
    }
  }
  return count;
}
```

```js
function countPalindromicSubstr(s) {
  const n = s.length;
  let count = 0;
  const dp = Array(n).fill(Array(n).fill(false));
  // const dp = Array.from({ length: n }, () => Array(n).fill(false));

  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
    count++;
  }

  for (let length = 2; length <= n; length++) {
    for (let i = 0; i <= n - length; i++) {
      const j = i + length - 1;
      if (s[i] === s[j]) {
        if (length == 2 || dp[i + 1][j - 1]) {
          dp[i][j] = true;
          count++;
        }
      }
    }
  }

  return count;
}
```

### 11.remove duplicate characters in a string

112.https://bigfrontend.dev/problem/remove-duplicate-letters-in-a-string

```js
function removeDuplicateLetters(s) {
  const charFrequency = {};
  const includedInResult = new Set();
  const result = [];

  // Count the frequency of each character in the string
  for (const char of s) {
    if (charFrequency[char]) {
      charFrequency[char]++;
    } else {
      charFrequency[char] = 1;
    }
  }

  for (const char of s) {
    // Decrease the frequency count for the current character
    charFrequency[char]--;

    // If the character is already included in the result, skip it
    if (includedInResult.has(char)) {
      continue;
    }

    // Remove characters from the result if the current character is smaller
    // than the last character in the result and the last character can still appear later
    while (
      result.length > 0 &&
      char < result[result.length - 1] &&
      charFrequency[result[result.length - 1]] > 0
    ) {
      includedInResult.delete(result.pop());
    }

    // Add the current character to the result and mark it as included
    result.push(char);
    includedInResult.add(char);
  }

  // Join the result array to form the final string
  return result.join("");
}

const input = "xyzabcxyzabc";
console.log(removeDuplicateLetters(input)); // Output: 'abcxyz'
```

### 12.the angle between hour hand and minute hand of a clock

132.https://bigfrontend.dev/problem/the-angle-between-hour-hand-and-minute-hand-of-a-clock

```js
/**
 * @param {string} time
 * @returns {number}
 */
function angle(time) {
  const [hours, minutes] = time.split(":").map(Number);
  const hoursDegree =
    ((hours >= 12 ? hours - 12 : hours) / 12) * 360 + (minutes / 60) * 30;
  const mintuesDegree = (minutes / 60) * 360;
  console.log(`${hoursDegree}-${mintuesDegree}`);
  const angle = Math.abs(hoursDegree - mintuesDegree);
  return Math.round(Math.min(angle, 360 - angle));
}
console.log(angle("12:15"));
```

### 13.roman numerals to integer

133.https://bigfrontend.dev/problem/roman-numerals-to-integer

```js
/**
 * @param {string} str - roman numeral string
 * @returns {number} integer
 */
function romanToInteger(roman) {
  const romanToIntMap = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
  };

  let result = 0;
  for (let i = 0; i < roman.length; i++) {
    const currentVal = romanToIntMap[roman[i]];
    const nextVal = romanToIntMap[roman[i + 1]];

    if (nextVal > currentVal) {
      result -= currentVal;
    } else {
      result += currentVal;
    }
  }

  return result;
}
```

### 14.integer to roman numerals

163.https://bigfrontend.dev/problem/integer-to-roman

```js
/**
 * @param {number} integer
 * @returns {string} str - roman numeral string
 */
function integerToRoman(num) {
  // Define a list of tuples with Roman numeral symbols and their corresponding values.
  const romanSymbols = [
    { value: 1000, symbol: "M" },
    { value: 900, symbol: "CM" },
    { value: 500, symbol: "D" },
    { value: 400, symbol: "CD" },
    { value: 100, symbol: "C" },
    { value: 90, symbol: "XC" },
    { value: 50, symbol: "L" },
    { value: 40, symbol: "XL" },
    { value: 10, symbol: "X" },
    { value: 9, symbol: "IX" },
    { value: 5, symbol: "V" },
    { value: 4, symbol: "IV" },
    { value: 1, symbol: "I" },
  ];

  let result = "";

  // Iterate over the romanSymbols array
  for (let i = 0; i < romanSymbols.length; i++) {
    const { value, symbol } = romanSymbols[i];
    // Subtract the value from num and append the symbol to result until num < value
    while (num >= value) {
      num -= value;
      result += symbol;
    }
  }

  return result;
}
```

### 15.implement `btoa()`

141.https://bigfrontend.dev/problem/implement-btoa

1. convert the string to binary format.
2. Pad 0 behind to make sure the length can be divided by 6.
3. split the string to 6 bits and convert it to the index and lookup for the base64 chars.
4. Add "=" to make sure the length of result can be divided by 4.

```js
/**
 * @param {string} str - binary string
 * @returns {string}
 */
function myBtoa(binaryString) {
  const base64Chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  let binary = [...binaryString]
    .map((char) => char.charCodeAt(0).toString(2).padStart(8, "0"))
    .join("");
  // Pad zeros to make sure the length can be divided by 6
  if (binary.length % 6 !== 0) {
    binary += "0".repeat(6 - (binary.length % 6));
  }
  const n = binary.length;
  let base64 = Array(Math.floor(n / 6))
    .fill(0)
    .map((_, index) => binary.slice(index * 6, index * 6 + 6))
    .map((chunk) => base64Chars[parseInt(chunk, 2)])
    .join("");

  // Ensure input length is a multiple of 4
  const padding = base64.length % 4;
  if (padding > 0) {
    base64 += "====".slice(padding);
  }
  return base64;
}
```

### 16.implement `atob()`

160.https://bigfrontend.dev/problem/implement-atob
`atob()` decodes a string of data which has been encoded using Base64 encoding.

```js
/**
 * @param {string} encoded
 * @return {string}
 */
function myAtob(input) {
  const createBase64Lookup = () => {
    // Base64 characters
    const base64Chars =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    // 26 + 26 + 10 + 2 = 64
    const base64Lookup = Object.fromEntries(
      base64Chars.split("").map((char, index) => [char, index]),
    );
    return base64Lookup;
  };
  // Ensure input length is a multiple of 4
  if (input.length % 4 !== 0) {
    throw new Error("Invalid base64 string");
  }

  // Remove padding characters
  input = input.replace(/=+$/, "");

  const base64Lookup = createBase64Lookup();
  // Convert each character to its 6-bit binary representation
  const binaryString = [...input]
    .map((char) => base64Lookup[char].toString(2).padStart(6, "0"))
    .join("");

  if (binaryString.length > 0 && binaryString.length < 8) {
    throw new Error();
  }

  // Split the binary string into 8-bit chunks and convert to ASCII characters
  const n = binaryString.length;
  return Array(Math.floor(n / 8))
    .fill(0)
    .map((_, index) => binaryString.substring(8 * index, 8 * index + 8))
    .map((byte) => String.fromCharCode(parseInt(byte, 2)))
    .join("");
}
```

### 17.most frequently occurring character

145.https://bigfrontend.dev/problem/most-frequently-occurring-character

```js
/**
 * @param {string} str
 * @returns {string | string[]}
 */
function count(str) {
  const calFreq = (str) => {
    const freq = {};
    for (const char of str) {
      const val = freq[char] || 0;
      freq[char] = val + 1;
    }
    return freq;
  };
  const freq = calFreq(str);
  const maxFreq = Math.max(...Object.values(freq));
  const ans = Object.keys(freq).filter((key) => freq[key] === maxFreq);
  return ans.length === 1 ? ans[0] : ans;
}
```

### 18.semver compare

157.https://bigfrontend.dev/problem/semver-compare

```js
/**
 * @param {string} v1
 * @param {string} v2
 * @returns 0 | 1 | -1
 */
function compare(v1, v2) {
  const items1 = v1.split(".").map(Number);
  const items2 = v2.split(".").map(Number);
  if (items1.length !== 3 || items2.length !== 3) {
    throw new Error("input is not correct.");
  }
  for (let i = 0; i < 3; i++) {
    if (items1[i] !== items2[i]) {
      return items1[i] < items2[i] ? -1 : 1;
    }
  }
  return 0;
}
```

### 19.remove characters

165.https://bigfrontend.dev/problem/remove-characters

```js
/**
 * @param {string} input
 * @returns string
 */
function removeChars(input) {
  let ans = input;
  let reducedSize = input.length;
  while (reducedSize > 0) {
    const size = ans.length;
    ans = ans.replaceAll("b", "").replaceAll("ac", "");
    reducedSize = size - ans.length;
  }
  return ans;
}
```

### 20.validate number string

166.https://bigfrontend.dev/problem/validate-number-string-1

```js
function validateNumberString(str) {
  // Define the regular expression pattern for valid numbers
  // const pattern = /^[\+\-]?(\d+)?(\.)?(\d+)?(e[\+\-]?\d+)?$/i;
  const pattern = /^[\+\-]?(\d+(\.\d*)?|\.\d+)(e[\+\-]?\d+)?$/i;
  // Test the input string against the pattern
  // [\+\-]?
  // (\d+(\.\d*)?|\.\d+) => \d+(\.\d*)? or \.\d+
  // (e[\+\-]?\d+)? => e, [\+\-]?, \d+
  return pattern.test(str);
}
```

### 21.uncompress string

173.https://bigfrontend.dev/problem/uncompress-string
Example:

```js
uncompress("3(ab)"); // 'ababab'
uncompress("3(ab2(c))"); // 'abccabccabcc'
```

The basic structure is a structure like `ab2(c)`. The first part is letters part: `ab`. The second part is a numbers part: `2`. The last part is wrapped with `()` and contains the similar structure.

When a `(` is met, we need to push `ab` and `2` to the stack. and reset `curStr` and `curNum`. When a `)` is met, we need pop out, `curStr` and `curNum` and calculate the result.

```js
/**
 * @param {string} str
 * @returns {string}
 */
function uncompress(s) {
  let stack = [];
  let currNum = 0;
  let currStr = ""; // Track the current string between ( and )

  for (let char of s) {
    if (char === "(") {
      stack.push([currStr, currNum]);
      currStr = "";
      currNum = 0;
    } else if (char === ")") {
      const [prevStr, num] = stack.pop();
      currStr = prevStr + currStr.repeat(num);
    } else if (Number.isNaN(parseInt(char))) {
      currStr += char;
    } else {
      currNum = currNum * 10 + parseInt(char);
    }
  }

  return currStr;
}
```
